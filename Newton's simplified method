# Ньютон упрощенный
import time

def cubic_equation(x, a, b, c, d):
    return a * x**3 + b * x**2 + c * x + d

def cubic_derivative(x, a, b, c):
    return 3 * a * x**2 + 2 * b * x + c

def simplified_newton_method(a, b, c, d, epsilon=1e-5, max_iter=100):
    start_time = time.time()

    # Выбор начальной точки с учетом выпуклости
    x0 = 0.5

    # Вычисляем производную только один раз в начальной точке
    f_prime_x0 = cubic_derivative(x0, a, b, c)

    print(f"\nУпрощенный метод Ньютона для уравнения: {a}x³ + {b}x² + {c}x + {d} = 0")
    print(f"Начальная точка x0 = {x0:.6f} (выбрана с учетом отрицательности f(x) и f''(x))")
    print(f"Производная в x0: f'(x0) = {f_prime_x0:.6f} (фиксируется на всех итерациях)")
    print("\nИтерационный процесс:")
    print("-" * 90)
    print(f"{'Итерация':<8} | {'x[n]':<15} | {'f(x[n])':<15} | {'f\'(x0)':<15} | {'Delta x[n]':<15}")
    print("-" * 90)

    iterations = []
    for i in range(max_iter):
        f_x = cubic_equation(x0, a, b, c, d)

        if abs(f_prime_x0) < epsilon:
            print("Производная слишком мала, возможно деление на ноль.")
            break

        delta_x = f_x / f_prime_x0
        x1 = x0 - delta_x
        iterations.append((i, x0, f_x, f_prime_x0, delta_x, abs(f_x)))

        print(f"{i:<8} | {x0:<15.6f} | {f_x:<15.6f} | {f_prime_x0:<15.6f} | {delta_x:<15.6f}")

        if abs(delta_x) < epsilon:
            break

        x0 = x1

    end_time = time.time()
    execution_time = end_time - start_time

    print("-" * 90)
    print(f"\nРезультат:")
    print(f"Найденный корень: x = {x0:.6f}")
    print(f"Значение ошибки: f(x) = {cubic_equation(x0, a, b, c, d):.6f}")
    print(f"Количество итераций: {len(iterations)}")
    print(f"Время: {execution_time:.6f} секунд")

    return x0, iterations, execution_time

a = 2
b = -4
c = -2
d = 1
epsilon = 1e-5

root, iterations, exec_time = simplified_newton_method(a, b, c, d, epsilon)
